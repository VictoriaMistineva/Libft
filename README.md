# Libft Creating your own library of functions in C


### int ft_atoi(const char *str);

Принимает на вход указатель на строку. В строке могут быть не только цифры, но и буквы, знаки препинания и прочее. Так же знак плюса и минуса. Вернуть числовое значение типа int " В начале строки пропускает символы isspace до момента появления знака (знак плюса может присутствовать, но игнорируется при выводе). Если после знака минуса (или плюса) находиться что-то кроме цифры (в том числе еще один знак минуса или плюса), то возвращает 0. Далее в строке идет считывание символов до тех пока либо строка не закончиться, либо встретиься что-то кроме цифры. После того, как число доходит до предельных значений int (-2 млрд --- 2 млрд) происходит движение числа по кругу int. Например если приходит строка с числом 2147483648, то на выходе будет число - 2147483648. Так происходит до тех пор пока число знаков в строке не станет равной 19. При этом условии: если число положительное, то возвращается -1, если число полодительное, то 0."

### void ft_bzero(void *s, size_t n);

Принимает номер символа Ничего не возвращает Записывает n раз 0 в строку по указателю s. Если n=0, то функция ничего не делает. Если n=0, то функция ничего не делает. Можно воспользоваться функцией ft_memset

### void *ft_calloc(size_t count, size_t size);

Выделяет память для count*size байт и заполняет их нулями. Возвращает указатель на выделенную память Можно воспользоваться функцию ft_bzero. Возвращаемый указатель имеет тип void.

### int ft_isalnum(int c);

Принимает номер символа Возвращает 0, если символ не является числом или буквой. И возвращает с , если он является числом или буквой Проверяетявляется ли символ числом или буквой.

### int ft_isalpha(int c);

Принимает номер символа Возвращает 0 если символ не является буквой. И возвращает с если это буква Буква может быть как большая так и маленькая. Проверяется по ASCII

### int ft_isascii(int c);

Принимает номер символа Возвращает 0 если символ не входит в ASCII. И возвращает с если входит с >= 0 && c <= 127

### int ft_isdigit(int c);
 
Принимает номер символа Возвращает 0 если символ не является цифрой. И возвраащет сб если число

### int ft_isprint(int c);

Принимает номер символа Возвращает 0 если символ НЕпечатаемый. И возвращает 1, если символ печатаемый с > 31 && c < 127. 127 символ (del) также непечатаемый

### char ft_itoa(int a);

Принимает число типа int Переводит число в строку и возвращает указатель на эту строку Нужно обязательно учитывать знак числа

### void *ft_memccpy(void dst, const void src, int c, size_t n);

Принимает указатель на строку dst в нее копируем n байт из строки src до тех пор пока не встретиться символ c в строке src В случае когда все скопировалось возвращает NULL. В случае когда в строке src встретился символ 'c' они копируется в dst копирование останавливается и возвращается указатель на следующий символ в строке dst Символ 'c' обязательно нужно склпировать в dst. Если строки перекрываются то поведение не определено

### void *ft_memcpy(void dst, void src, size_t n);

Принимает указатель на строку dst,в которую нужно скопировать n байт из строки src Возвращает указатель dst Нужно проверить строки dst и src на существование. Беспокоиться о том, что строка src может быть меньше чем n не стоит. Если строки перекрываются то поведение не определено

### void ft_memchr(const void s, int c, size_t n);

Принимает указатель на массив s и n - число байтов, в пределах которых нужно проверить наличие символа 'c'. Возвращает NULL, если символ 'c' в пределах n байт не был найден. И возвращает указатель на символ 'c' в строке s Символ 'c' приходит как intи нужно приводить к unsigned char

### int ft_memcmp(const void s1, const void s2, size_t n);
 
Принимает указатели на массив s1 и s2, в которых сравнивает первые n байт. Возвращает 0, если байты одинаковые, отрицательное число, если байт в s2 больше и положительное число, если s1 больше (int)*a - *b;

### void *ft_memmove(void dst, const void src, size_t len);

Копирует len байт из строки src в строку dst Возвращает указатель на dst. В случае когда строки пересекаются, необходимо сравнить адреса dst и src и если dst > src то копировать с конца (dst[--len] = src[len]). Во всех остальных случаях можно использовать ft_memcpy

### void ft_memset(void b, int c, size_t len);

Принимает указатель на массив b, в который записывает len байтов с Возвращает указатель на b Проверку на выход за пределы строки делать не надо

### void ft_putchar_fd(char c, int fd);

Принимает файловый дескриптор, используя который нужно записать в файл символ с Ничего не возвращает Использует функцию write, где первым параметром использвать файловый дескриптор

### void ft_putstr_fd(char c, int fd);

Принимает файловый дескриптор fd по которому записать в файл строку, на которую указывает указатель s Ничего не возвращает Проверить строку на существование. Использовать функцию write]

### void ft_putendl_fd(char s, int fd);

Принимает файловый дескриптор fd, по которому записать строку s и после добавить символ перевода каретки \n Ничего не возвращает Проверить строку на существование. Использовать функцию write И использовать функцию ft_putstr_fd

### void ft_putnbr_fd(int n, int fd);

Принимает файловый дескриптор, по которому записать в файл число n Ничего не возвращает Использовать рекурсию. И привести n к unsigned int

### char **ft_split(char const *s, char c);

Принимает указатель на строку s, кторую нужно разделить по символу c и записать в массив строк Вернуть массив строк Использовать кастомные функции для подсчета слов и подсчета символов в слове. Учесть, что разделитель может быть перед строкой и в конце строки. Учесть , что в самой строке разделители могут идти подряд друг за другом

### char *ft_strtrim(char const str, char const set);

Удалить символы из строки set в начале и конце строки s Вернуть указатель на строку, которую выделили mallocoм память и скопировали полученную строку Использовать ft_strchr и ft_substr

### char *ft_substr(char const *s, unsigned int start, size_t len); 

Принимает указатель на строку s, из которой нужно скопировать len символов начиная с индекса start в новую строку, которую выделили mallocом Вернуть указатель на новую строку "Учесть, что строки s может не быть. Защитить malloc. Если start >= длине s, то вернуть укзатель на пустую строку, выделенную mallocом. ВАЖНОЕ ЗАМЕЧАНИЕ! Один из пиров отметил, что нужно сравнивать длину строки s и размер len и mallocom выделяить память для наименьшей величины. Пример: длина строки s==10, а len приходит 500. Если проигнорировать аспект сравнения, то будет выделено лишних 490 байт. Так же malloc может не выдать память для строки из 10 байт, т.к. не будет 500 хотя реально нужно 10. В моем коде такой проверки нет, т.к. ориентируюсь на Мулинет. "

### char ft_strdup(const char s1);

Принимает строку s1, которую нужно скопировать в новую строку, выделенную mallocом Вернуть указатель на новую строку Защитить malloc

### char ft_tolower(int c);

Переводит и возвращает символ 'c', если это большая буква в маленькую

### char ft_toupper(int c);

Переводит и возвращает символ 'c', если это маленька буква в большую

### size_t ft_strlcat(char dst, const char src, size_t dstsize);

Принимает указатель на буффер dst с размером dstsize,в который нужно сконкотинатить строку src и ОБЯЗАТЕЛЬНО закончить полученную строку NUL-терминатором Возвращает длину строки, которую может создать. Если размер dst >= dstzize,то вернуть dstsize+длину src.

### size_t ft_strlen(const char s);

Принмает указатель на строку s Возвращает длину s

### char ft_strchr(const char s, int c);

Принимает указатель на строкуб в которой нужно найти первое вхождение символа 'c' Вернуть указатель на на символ 'c' в строке s. Если его в строке нет вернуть NULL. Если в качестве искомого символк 'c' пришел '\0', то вернуть указатель на '\0' строки s Сделать проверку на то, что символ 'c' это '\0'.

### char ft_strrchr(const char s, int c);

Принимает указатель на строкуб в которой нужно найти последнее вхождение символа 'c' Вернуть указатель на на символ 'c' в строке s. Если его в строке нет вернуть NULL. Если в качестве искомого символк 'c' пришел '\0', то вернуть указатель на '\0' строки s Сделать проверку на то, что символ 'c' это '\0'.

### char *ft_strjoin(char const s1, char const s2);

Принимает указатели на строки s1 и s2, которые нужно объединить и скопировать в строку, которую выделить mallocом. В конце полученной строки обязательно '\0' Вернуть указатель на полученную строку Прповерить строки s1 и s2 на существованиею

### size_t ft_strlcpy(char dst, const char src, size_t dstsize);

Принимает указатели на строку dst, в которую нужно скаопировать dstsize байт из строки src Возвращает длину строку, которую могбы скопировать (длина src) "Проверить указатели на существование. Если dstsize == 0, то вернет длину src. В конце скопированной строки обязательн поставить '\0'"

### char *ft_strmapi(char const s, char (f)(unsigned int, char));

Принимает указатель s на строку. Выделяет mallocom память для новой строки, в которую нужно сокпировать символы из строки s, к каждому символу которой применитиь функцию f. Возвращает указатель на новую строку Проверить строку и функцию на существование

### int ft_strncmp(const char s1, const char s2, size_t n);

Принимает указатели на строки s1 и s2, в которых сравнивает первые n байт в лексикографическом порядке Возвращает 0, если чтроки равны. Положительное значение, если строка s1 > s2 и отрицательное значение, если чтрока s1 < s2 "Строки. проверяются до тех пор пока не закончатся обе или не закончатся количество сравниваемых байтов. Если одна из строк закончилась раньше чем n, то сравнение продолжиться еще на один байт, где будет сравниваться конц закончившейся строки и следующий символ другой строки"

### char *ft_strnstr(const char str, const char to_fibd, size_t len);

Принимает указатель на строку str, в которой на протяжении len байт ищет сроку to_find "Если строки to_find не существует, то вернуть указатель на str. Если строка не найдена возвращает NULL. Во всех остальных случаях возвращает указатель на начало строки to_find в строке str " NUL-терминатор строки to_find не учитывается
